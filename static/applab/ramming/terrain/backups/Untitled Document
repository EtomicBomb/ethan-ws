var TAU = 2*Math.PI;
var SQRT_3 = Math.sqrt(3);

setActiveCanvas("canvas");

var seed = randomNumber(1000, 100000);
setStrokeColor("#00000000");

function toColor(fraction) {
  if (fraction < 0.5) {
    return "#00DADA"; // light blue
  } else if (fraction < 0.8) {
    return "tan";
  } else {
    return "#006400"; // dark green
  }
}

function newMap(setX, setY, scale) {
  return function(oldX, oldY, oldR) {
    return {
      x: scale*(oldX-setX) + 160,
      y: scale*(oldY-setY) + 225,
      r: scale*oldR,
    };
  };
}

/*

for (var x=0; x<100; x++) {
  for (var y=0; y<100; y++) {
    //console.log(randomFraction(Math.pow(x, y)));

    
    var color = toColor(perlin(x/30, y/30, seed));
    setFillColor(color);
    rect(3*x, 3*y, 3, 3);
  }
}
*/

var hexagons = makeHexagons(5, 10);
hexagonCanvas(hexagons);
showElement("hexagonCanvas");



function makeHexagons(rows, columns) {
  var hexagons = [];
  var width = 5;
  for (var gridY=0; gridY<rows; gridY++) {
    var row = [];
    for (var gridX=0; gridX<columns; gridX++) {
      // lets convert these to screen coords
      var 
        pos = hexagonMap(gridX, gridY, width),
        x = pos[0],
        y = pos[1],
        color = toColor(perlin(x/50, y/50, seed));
      
      row.push(color);
    }
    hexagons.push(row);
  } 
  return hexagons;
}

  
function hexagonCanvas(hexagons) {
  createCanvas("hexagonCanvas", 320, 450);
  hideElement("hexagonCanvas");
  setActiveCanvas("hexagonCanvas");
  
  hexagon(50, 50, 20, "red");
  
  var width = 5;
  
  for (var gridY=0; gridY<hexagons.length; gridY++) {
    var row = hexagons[gridY];
    for (var gridX=0; gridX<row.length; gridX++) {
      var 
        pos = hexagonMap(gridX, gridY, width),
        screenX = pos[0],
        screenY = pos[1],
        color = row[gridX];
      
      hexagon(screenX, screenY, width, color);
    }
  }
}



function fractionPart(a) {
  return a - Math.floor(a);
}

function randomFraction(seed) {
  var x = Math.sin(seed)*10000;
  return fractionPart(x);
}

function lerp(a0, a1, w) {
  var value = w * w * w * (w * (w * 6 - 15) + 10);
  
  return a0 + (value)*(a1 - a0);
}

function stringHash(str) {
  // https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript
  var hash = 0, i, chr;
  for (i = 0; i < str.length; i++) {
    chr   = str.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
}


function dotGridGradient(ix, iy, x, y, baseSeed) {
  var hash = stringHash((1+9*ix).toString()+(9*iy+1)+baseSeed);
  var angle = TAU * randomFraction(hash);
  var gradientX = Math.cos(angle);
  var gradientY = Math.sin(angle);
  
  var gridShiftX = x - ix;
  var gridShiftY = y - iy;
  
  return gradientX*gridShiftX + gradientY*gridShiftY;
}

function perlin(x, y, baseSeed) {
  //https://en.wikipedia.org/wiki/Perlin_noise
  var gridX = ground(x);
  var gridY = ground(y);
  
  var wx = fractionPart(x);
  var wy = fractionPart(y);
  
  var n0 = lerp(
    dotGridGradient(gridX, gridY, x, y, baseSeed),
    dotGridGradient(gridX+1, gridY, x, y, baseSeed),
    wx    
  );
  
  var n1 = lerp(
    dotGridGradient(gridX, gridY+1, x, y, baseSeed),
    dotGridGradient(gridX+1, gridY+1, x, y, baseSeed),
    wx 
  );

  return 0.5+lerp(n0, n1, wy);
}

function ground(x) {
  return Math.floor(x);
}

function hexagonMap(gridX, gridY, w) {
  var xShift = gridY%2===0 ? 0 : 3*w/2;
  
  return [
    xShift+ gridX*w*3,
            gridY*w*Math.sqrt(3)/2,
  ];
}


function randomColor() {
  return rgb(
    randomNumber(0,255),
    randomNumber(0,255),
    randomNumber(0,255)
  );
}

function hexagon(x, y, w, color) {
  setStrokeWidth(w);
  setStrokeColor(color);
  var quarter_w = w/4;
  
  line(x, y-w*SQRT_3/2, x, y+w*SQRT_3/2);
  line(x+3*quarter_w, y-quarter_w*SQRT_3, x-3*quarter_w, y+quarter_w*SQRT_3);
  line(x+3*quarter_w, y+quarter_w*SQRT_3, x-3*quarter_w, y-quarter_w*SQRT_3);
}

