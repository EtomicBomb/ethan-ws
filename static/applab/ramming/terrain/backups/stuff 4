// TODO: make perlin noise super fast
var TAU = 2*Math.PI;
var COLOR_CLEAR = rgb(0, 0, 0, 0);

var SCREEN_WIDTH = 320;
var SCREEN_HEIGHT = 450;
var GRID_SQUARE_WIDTH = 20;

setActiveCanvas("canvas");

var start = getTime();

var game = new Game();

console.log(getTime()-start);



function Game() {
  this.eventClickBoatSprite = function (localPos, boat) {
    // we want to spawn a new 
    if (this.boatClickCrosshair) return;
    this.boat = boat;
    this.boatClickCrosshair = this.sprites.addSprite(CrosshairSprite, localPos[0], localPos[1]);
  }; 
  
  this.randomSeed = randomNumber(1000, 100000);
  this.sprites = new Sprites(this.randomSeed);
  
  this.sprites.addSprite(BoatSprite, 100, 200);
  
  
  var that = this;
  onEvent("main", "mousedown", function (event) {
    if (that.boatClickCrosshair) {
      that.sprites.deleteSprite(that.boatClickCrosshair.id);
      that.boatClickCrosshair = null;
      var endPos = that.sprites.map.fromScreen(event.x, event.y);
      var startPosX = that.boat.x;
      var startPosY = that.boat.y;
      var xDistance = endPos[0] - startPosX;
      var yDistance = endPos[1] - startPosY;
      
      var angle = Math.atan2(yDistance, xDistance);
      var r = Math.sqrt(xDistance*xDistance + yDistance*yDistance);
      var dx = xDistance/r;
      var dy = yDistance/r;
      
      var stepsLeft = Math.round(r);
      
      that.boat.setAngle(angle);
      var loopHandle = timedLoop(50, function() {
        startPosX += dx;
        startPosY += dy;
        that.boat.setPosition(startPosX, startPosY);
        
        stepsLeft--;
        if (stepsLeft === 0) {

          
          stopTimedLoop(loopHandle);
        }
      });
    }
  });
  
  onEvent("main", "mousemove", function (event) {
    if (that.boatClickCrosshair) {
      // we are tracking the 
      var local = that.sprites.map.fromScreen(event.x, event.y);
      that.boatClickCrosshair.setPosition(local[0], local[1]);
    }
  });
}


function Sprites(seed) {
  //  manipulating sprites and everything
  // includes both the grid and the sprite
  
  this.checkBackgroundCollisions = function () {
    var collide = [];
    for (var i=0; i<sprites.length; i++) {
      if (sprites[i]!== null && sprites[i].collidesWithBackground(background)) {
        collide.push(sprites[i]);
      }
    }
    
    return collide;
  };

  this.checkSpriteCollisions = function () {
    // returns a list of the sprites that collide
    var collide = [];
    
    // iterate through all pairs of objects
    for (var inc=1; inc < sprites.length; inc++) {
      for (var start=0; start+inc < sprites.length; start++) {
        var
          a = sprites[start],
          b = sprites[start+inc];
          
        if (a !== null && b !== null && a.collidesWithOther(b)) {
          collide.push(a);
          collide.push(b);
        }
      }
    }
    
    return collide;
  };

  this.deleteSprite = function (id) {
    var index = parseInt(id);
    sprites[index].delete();
    sprites[index] = null;
  };

  this.addSprite = function (constructor, x, y) {
    var id = sprites.length.toString();
    var sprite = new constructor(x, y, this.map, id);
    sprites.push(sprite);
    return sprite;
  };
  
  this.resizeUpdate = function () {
    // redraws the sprites and the grid
    this.map = new Map(this.topLeftX, this.topLeftY, this.scaleFactor);
    background.setMap(this.map);
    for (var i=0; i<sprites.length; i++) {
      if (sprites[i] !== null)
        sprites[i].setMap(this.map);
    }
  };
  
  var sprites = []; // may contain nulls
  this.map = new Map(0, 0, 1);
  var background = new Background(seed);

  var that = this;
  
  this.topLeftX = 0;
  this.topLeftY = 0;
  this.scaleFactor = 1;
  
  /*
  var lastX = null;
  var lastY = null;
  
  onEvent("main", "mousedown", function(event) {
    lastX = event.x - that.topLeftX;
    lastY = event.y - that.topLeftY;
  });
  
  onEvent("main", "mouseup", function() { lastX = null; });
  onEvent("main", "mouseout", function() { lastX = null; });
  
  onEvent("main", "mousemove", function(event) {
    if (lastX) {
      that.topLeftX = event.x-lastX;
      that.topLeftY = event.y-lastY;
      
      that.resizeUpdate();
    }
  });
  */
  
  onEvent("main", "keydown", function(event) {
    if (event.key == "Up" | event.key == "Down") {
      var f = (event.key=="Up")? 1.1 : 0.9;
      
      var dx = 160 - that.topLeftX;
      var dy = 225 - that.topLeftY;
      
      dx *= f;
      dy *= f;
      that.scaleFactor *= f;
      
      that.topLeftX = 160-dx;
      that.topLeftY = 225-dy;
      
      that.resizeUpdate();
    } else if ("wasd,oe".includes(event.key)) { // works with qwerty or dvorak
      var shift;
      if ("w,".includes(event.key)) {
        shift = [0, 10];
      } else if ("so".includes(event.key)) {
        shift = [0, -10];
      } else if ("a" == event.key) {
        shift = [10, 0]; 
      } else { // e or d
        shift = [-10, 0];
      }
      
      that.topLeftX += shift[0];
      that.topLeftY += shift[1];
      
      that.resizeUpdate();
    }
  });
}



function Map(cornerX, cornerY, scaleFactor) {
  this.toScreen = function (oldX, oldY, oldWidth, oldHeight) {
    var newX = cornerX + scaleFactor*oldX;
    var newY = cornerY + scaleFactor*oldY;
    
    return [newX, newY, oldWidth*scaleFactor, oldHeight*scaleFactor];
  };
  
  this.fromScreen = function (screenX, screenY) {
    // return it to the background coordinates
    return [
      (screenX - cornerX)/ scaleFactor,
      (screenY - cornerY)/ scaleFactor,
    ];
  };
}


function BoatSprite(x, y, map, id) {
  var hitbox = hitboxFrom("none", x, y);
  Sprite.call(this, x, y, 45, 26, map, id, hitbox, "boat.png");
  
  var that = this;
  onEvent(this.id, "click", function (event) {
    var localPos = that.map.fromScreen(event.x, event.y);
    
    game.eventClickBoatSprite(localPos, that);
  });
}

function CrosshairSprite(x, y, map, id) {
  var hitbox = hitboxFrom("none", x, y);
  Sprite.call(this, x, y, 45, 45, map, id, hitbox, "crosshair.png");
}

function SquareSprite(x, y, map, id) {
  var hitbox = hitboxFrom("square", x, y);
  
  Sprite.call(this, x, y, 28.28, 28.28, map, id, hitbox, "square.png");
  
  //var that = this;
  //onEvent(this.id, "click", function(event) {
  //  var local = that.map.fromScreen(event.x, event.y);
  //  game.eventSelectSquareSprite(local);
  //});
}


function Sprite(x, y, width, height, map, id, hitbox, imageName) {
  this.collidesWithBackground = function(background) {
    return this.hitbox.collidesWithBackground(background);
  };
  
  this.collidesWithOther = function(other) {
    return this.hitbox.collidesWithOther(other);
  };
  
  this.setMap = function(newMap) {
    this.map = newMap;
    this.resizeUpdate();
  };
  
  this.setAngle = function(newAngle) {
    this.angle = newAngle;
    setStyle(this.id, "transform: rotate("+ (this.angle) +"rad);");
    this.hitbox.setAngle(this.angle);
  };
  
  this.setPosition = function(newX, newY) {
    this.x = newX;
    this.y = newY;
    this.resizeUpdate();
    this.hitbox.setPosition(this.x, this.y);
  };

  this.resizeUpdate = function() {
    // draws the sprite
    var mapped = this.map.toScreen(this.x, this.y, this.width, this.height);
    var displayWidth = mapped[2];
    var displayHeight = mapped[3];
    setPosition(id, mapped[0]- displayWidth/2, mapped[1]-displayHeight/2, displayWidth, displayHeight);
  };
  
  this.delete = function() {
    this.hitbox = null;
    deleteElement(this.id);
  };
  
  this.x = x; // coordinates of the center
  this.y = y;
  this.width = width;
  this.height = height;
  
  this.angle = 0;
  this.map = map;
  this.hitbox = hitbox;
  this.id = id;
  
  button(this.id, "");
  //setStyle(this.id, "position: relative;");
  setProperty(this.id, "background-color", COLOR_CLEAR);
  setProperty(this.id, "image", imageName);
  setStyle(this.id, "padding: 0px;");

  this.resizeUpdate();
}







function LineSegment(x0, y0, x1, y1) {
  if (x0 == x1) x0 += 0.1;
  
  this.slope = (y1-y0)/(x1-x0);
  this.y_int = y0-this.slope*x0;
  var xMin = Math.min(x0, x1);
  var xMax = Math.max(x0, x1);
  var yMin = Math.min(y0, y1);
  var yMax = Math.max(y0, y1);

  this.includes_x = function(x) {
    return xMin <= x && x <= xMax;
  };
  
  this.includes_y = function(y) {
    return yMin <= y && y <= yMax;
  };

  this.intersectWithOther = function(other) {
    var x = (this.y_int - other.y_int)/(other.slope - this.slope);
    var y = this.slope*x+this.y_int;
    return this.includes_x(x) && other.includes_x(x) && this.includes_y(y) && other.includes_y(y);
  };
}


function hitboxFrom(kind, x, y) {
  var vertices;
  
  if (kind === "square") {
    vertices = [
      [20, TAU/8],
      [20, 7*TAU/8],
      [20, 5*TAU/8],
      [20, 3*TAU/8],
    ];
  } else if (kind === "none") {
    vertices = [];
  } else {
    throw "no hitbox called "+kind;
  }
  
  return new Hitbox(x, y, vertices);
}


function Hitbox(x, y, vertices) {
  this.setAngle = function(newAngle) {
    angle = newAngle;
    this.lines = this.getSlopeInterceptLines();
  };

  this.setPosition = function(newX, newY) {
    this.x = newX;
    this.y = newY;
    this.lines = this.getSlopeInterceptLines();
  };

  this.getPoint = function(i) {
    var 
      index = (i<this.vertices.length)? i : 0,
      vertex = this.vertices[index],
      r = vertex[0],
      newAngle = vertex[1]+angle;
      
    return [
      this.x+r*Math.cos(newAngle), 
      this.y+r*Math.sin(newAngle),
    ];
  };
  
  this.getSlopeInterceptLines = function() {
    var lines = [];
    for (var i=0; i<this.vertices.length; i++) {
      var
        start = this.getPoint(i),
        end = this.getPoint(i+1),
        lineSegment = new LineSegment(start[0], start[1], end[0], end[1]);
        
      lines.push(lineSegment);
    }
    return lines;
  };
   
  this.collidesWithOther = function(other) {
    if (distance(this.x, this.y, other.x, other.y) < this.maxRadius + other.maxRadius) {
      // they might collide, lets do a more in-depth check to see
      var thisLines = this.lines();
      var otherLines = other.lines();
      
      for (var i=0; i<thisLines.length; i++) {
        for (var j=0; j<otherLines.length; j++) {
          if (thisLines[i].intersectWithOther(otherLines[j])) {
            return true;
          }
        }
      }
      
      return false;
    } else {
      return false;
    }
  };
  
  this.collidesWithBackground = function(background) {
    for (var i=0; i<this.vertices.length; i++) {
      var 
        start = this.getPoint(i),
        x0 = Math.round(start[0]),
        y0 = Math.round(start[1]),
        end = this.getPoint(i+1),
        x1 = Math.round(end[0]),
        y1 = Math.round(end[1]),
        
        dx = x1 - x0,
        dy = y1 - y0;

      var lineX, lineY;
      
      if (dx !== 0) {
        // https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm

        var dError = Math.abs(dy/dx);
        var error = 0;
        
        lineY = y0; // possible bugt
        
        var xMin = Math.min(x0, x1);
        var xMax = Math.max(x0, x1);
        
        for (lineX=xMin; lineX<=xMax; lineX++) {
          if (!background.isEmpty(lineX, lineY)) return true;
          
          error += dError;
          if (error >= 0.5) {
            lineY += dy > 0 ? 1 : -1;
            error -= 1;
          }
        }
        
      } else {
        // we have a vertical line
        var yMin = Math.min(y0, y1);
        var yMax = Math.max(y0, y1);
        
        lineX = x0;
        for (lineY=yMin; lineY<=yMax; lineY++) {
          if (!background.isEmpty(lineX, lineY)) return true;
        }
      }
    }
    
    return false;
  };
  
  
  var angle = 0;
  this.x = x;
  this.y = y;
  this.vertices = vertices;
  this.lines = this.getSlopeInterceptLines();
  
  this.maxRadius = 0;
  for (var i=0; i<this.vertices.length; i++) {
    this.maxRadius = Math.max(this.maxRadius, vertices[i][0]);
  }
}

function hslToRgb(h, s, l) {
  // https://stackoverflow.com/a/9493060
  var r, g, b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    var hue2rgb = function hue2rgb(p, q, t){
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return rgb(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
}

function toCode(fraction) {
  if (fraction < 0.65) {
    return 0;
  } else if (fraction < 0.8) {
    return 1;
  } else {
    return 2;
  }
}
function toColor(fraction) {
  var d;
  if (fraction < 0.65) {
    d = (0.65- fraction)/(0.65*2);
    return hslToRgb(0.5, 1, 1-d/2-0.2); // light blue
  } else if (fraction < 0.8) {
    d = (0.8-fraction)/0.8;
    return hslToRgb(0.08, 0.42, d/2+0.6);
  } else {
    return hslToRgb(1/3, 0.88, 0.3-map(fraction, 0.8, 1.0, 0.0, 0.05));
  }
}

function map(x, in_min, in_max, out_min, out_max) {
  // https://www.arduino.cc/reference/en/language/functions/math/map/
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


function emptyArray(size) {
  var array = [];
  for (var i=0; i<size+1; i++) {
    array.push([]);
  }
  return array;
}

function Background(seed) {
  this.setPosition = function(x, y, scaleFactor) {
    setPosition("canvas", x, y, 320*scaleFactor, 450*scaleFactor);
  };
  
  this.setMap = function(newMap) {
    var mapInfo = newMap.toScreen(0, 0, 320, 450);
    setPosition("canvas", mapInfo[0], mapInfo[1], mapInfo[2], mapInfo[3]);
  };
  
  this.isEmpty = function(gridX, gridY) {
    var newX = Math.round(map.toScreen(gridX, 0, SCREEN_WIDTH, 0, SCREEN_WIDTH/GRID_SQUARE_WIDTH));
    var newY = Math.round(map.toScreen(gridY, 0, SCREEN_HEIGHT, 0, SCREEN_WIDTH/GRID_SQUARE_WIDTH));
    if (this.matrix[newY][newX] === 0) {
      return true;
    } else {
      return false;
    }
  };
  
  this.setPosition(0, 0, 1);
  
  this.init = function() {
    var columns = SCREEN_WIDTH/GRID_SQUARE_WIDTH;
    var rows = SCREEN_HEIGHT/GRID_SQUARE_WIDTH;
    var featureSizeConstant = 4;
    
    var memo = emptyArray(featureSizeConstant);
    
    
    setActiveCanvas("canvas");
    setStrokeColor(COLOR_CLEAR);

    this.matrix = [];

    for (var gridY=0; gridY<rows; gridY++) {
      var row = [];
      for (var gridX=0; gridX<columns; gridX++) {
        // lets convert these to screen coords

        var perlinFraction = perlin(
          gridX/rows*featureSizeConstant,
          gridY/rows*featureSizeConstant,
          seed,
          memo
        );
        row.push(toCode(perlinFraction));

        setFillColor(toColor(perlinFraction));
        rect(GRID_SQUARE_WIDTH*gridX, GRID_SQUARE_WIDTH*gridY, GRID_SQUARE_WIDTH, GRID_SQUARE_WIDTH);
      }
      this.matrix.push(row);
    } 
  };
  this.init();
}

function distance(x0, y0, x1, y1) {
  var dx = x1-x0;
  var dy = y1-y0;
  return Math.sqrt(dx*dx + dy*dy);
}


function ground(x) {
  return Math.floor(x);
}
function fractionPart(a) {
  return a - Math.floor(a);
}
function randomFraction(seed) {
  var x = Math.sin(seed)*10000;
  return x-Math.floor(x);
}



function scramble(n) {
  // https://stackoverflow.com/a/1299602
  n = ((n >> 16) ^ n) * 0x45d9f3b;
  n = ((n >> 16) ^ n) * 0x45d9f3b;
  n = (n >> 16) ^ n;
  return n;
}


function lerp(a0, a1, w) {
  var value = w * w * w * (w * (w * 6 - 15) + 10);
  return a0 + value*(a1 - a0);
}

function dotBackgroundGradient(ix, iy, x, y, baseSeed, memo) {
  var angle;

  if (memo[iy] && memo[iy][ix]) {
    angle = memo[iy][ix];
  } else {
    var hash = (baseSeed+scramble(ix)+scramble(iy)) % 100000;
    angle = TAU * randomFraction(hash);
    memo[iy][ix] = angle;
  }
  
  var gradientX = Math.cos(angle);
  var gradientY = Math.sin(angle);
  
  var gridShiftX = x - ix;
  var gridShiftY = y - iy;
  
  return gradientX*gridShiftX + gradientY*gridShiftY;
}

function perlin(x, y, baseSeed, memo) {
  // https://en.wikipedia.org/wiki/Perlin_noise
  var gridX = ground(x);
  var gridY = ground(y);
  
  var wx = fractionPart(x);
  var wy = fractionPart(y);
  
  var n0 = lerp(
    dotBackgroundGradient(gridX, gridY, x, y, baseSeed, memo),
    dotBackgroundGradient(gridX+1, gridY, x, y, baseSeed, memo),
    wx
  );

  
  var n1 = lerp(
    dotBackgroundGradient(gridX, gridY+1, x, y, baseSeed, memo),
    dotBackgroundGradient(gridX+1, gridY+1, x, y, baseSeed, memo),
    wx 
  );

  return 0.5+lerp(n0, n1, wy);
}


function uniqueID() {
  // kill me later for this
  return randomNumber(0, 999999999).toString();
}

function randomColor() {
  return rgb(
    randomNumber(0,255),
    randomNumber(0,255),
    randomNumber(0,255)
  );
}
